<h1>Assembly overview</h1>

This is an attempt to gather basic information about assembly and its basic elements. 

Learning Resource: https://www.youtube.com/watch?v=75gBFiFtAb8

## What is binary exploitation?

Binary exploitation is the process of taking compiled executables and making them do what you want them to do.

## Compilers

When you write a C program and start with the process of compiling it, your C file is read by the compiler, which will convert the code that you have written into a sequence of operations that will be executed by a computer. This sequence of operations are written in assembly.

For example:

```
#include <stdio.h>

void main(void)
{
	puts("Hello World!");
}
```

This C code isn't what is gonna run on your computer, for its instructions to be executed it first needs to be compiled into assembly code:

```
gcc hello.c -o hello
```

Using `objdump`we can see what the assembly code of this program looks like:

```
0000000000001149 <main>:
    1149:	f3 0f 1e fa          	endbr64 
    114d:	55                   	push   rbp
    114e:	48 89 e5             	mov    rbp,rsp
    1151:	48 8d 3d ac 0e 00 00 	lea    rdi,[rip+0xeac]        # 2004 <_IO_stdin_used+0x4>
    1158:	e8 f3 fe ff ff       	call   1050 <puts@plt>
    115d:	90                   	nop
    115e:	5d                   	pop    rbp
    115f:	c3                   	ret    
```

In order to understand what is actually happening when you run an executable, you must understand assembly. But to understand assembly, you first need to understand the basic elements of an executable.

There are two main architectures that dictate how our programs are compiled and executed: 32-bit(x86) and 64-bit(x64).

Every C program has four main components:
<ol>
  <li>Heap</li>
  <li>Stack</li>
  <li>Registers</li>
  <li>Instructions</li>
</ol>

## Heap

The heap is an area in memory designed for the purpose of manual memory allocation. Memory is allocated on the heap wheneaver functions such as `malloc` and `calloc` are called, as well as when global or static variables are declared.

(The inner workings of the heap are extremely complicated ,so this is all I am going to mention about it on this overview)

## Registers

Registers are essentially small storage areas in your processor, they can be used to store memory addresses, values, etc. Here is a list of the **x64** registers, and what their common use cases are:

```
rbp: Base Pointer, points to the bottom of the stack
rsp: Stack Pointer, points to the top of the stack
rip: Instruction Pointer, points to the instruction to be executed

General Purpose Registers
These can be used for a variety of different things
rax:
rbx:
rcx:
rdx:
rsi:
rdi:
r8:
r9:
r10:
r11:
r12:
r13:
r14:
r15:
```
In **x64** Linux passes arguments to a function via registers. The first few arguments are passed by these registers:

```
rdi:    First Argument
rsi:    Second Argument
rdx:    Third Argument
r10:    Fourth Argument
r8:     Fifth Argument
r9:     Sixth Argument
```

There are also different sizes for registers. The typical sizes we will be dealing with are : `64` bit, `32` bit, `16` bit, and `8` bit.

```
+-----------------+---------------+---------------+------------+
|   64 bit	  |     32 bit    |    16 bit     |    8 bit   |
+-----------------+---------------+---------------+------------+
|   rbp           |     ebp       |     bp        |     bpl    |
|   rsp           |     esp       |     sp        |     spl    |
|   rax           |     eax       |     ax        |     al     |
|   rbx           |     ebx       |     bx        |     bl     |
|   rcx           |     ecx       |     cx        |     cl     |
|   rdx           |     edx       |     dx        |     dl     |
|   rsi           |     esi       |     si        |     sil    |
|   rdi           |     edi       |     di        |     dil    |
+-----------------+---------------+---------------+------------+
```
## The stack 

The stack is a data structure comprised of elements that are added and removed with two operations: `push` and `pop`.

Push adds an element to the top of the stack:

```
push   rbp
```

While pop removes the top element from the stack:

```
pop    rbp
```

Each element on the stack is assigned to a stack address. Elements that are higher on the stack have a lower address than those on the bottom of the stack. In other words, the stack towards lower memory addresses.

Whenever a function is called, that function is set up with what is called the stack frame. All the local variables for that function will be stored in that function stack frame. That brings us to two of the special registers mentioned earlier:

<ul>
<li>The <strong>rbp</strong> register - Also known as the base pointer, contains the address of the base of the current stack frame. </li>
<li>The <strong>rsp</strong> register - Also referred to as a stack pointer, contains the address of the top element of the current stack frame.</li>
</ul>

All the space between this two registers make up the stack frame of whatever function is currently being called. All the stack addresses outside of the current stack frame are considered junk by the compiler.

Let's go over a simple example of what happens when a function its called from main, how its stack frame is set up, and how its variables are stored on the stack.

example.c
```
#include <stdio.h>
#include <stdlib.h>

void func(int x)
{
    int a = 0;
    int b = x;
}

int main()
{
    func(10);
}
```

The function takes one integer as a parameter, and declares two local integers, one initialize to zero, and the other initialize to the function's argument.

First, the value of the argument is pushed onto the stack, then, the return address of the function is pushed onto the stack. The return address is simply the four byte address of the instruction that will be executed as soon as the function has gone out of the scope.

Then, the base pointer is pushed onto the stack:

```
push   rbp
```

Then the stack pointer's value is given to the base pointer:

```
mov    rbp,rsp
```

Finally the stack pointer is decremented to make room for the local variables.

Depending on your compiler, the number of bytes that the stack pointer is decremented by may vary. All the space in memory between the stack pointer and the base pointer is our function stack frame. This sequence of instructions is called the function prologue. The prologue is performed whenever a function is called.

Since our function's first local variable is initialized to 0, the value 0 will be moved into the memory address, 4 bytes bellow the base pointer.

This is because an integer is 4 bytes. The local variable is now on location rbp - 0x4. Now on to our second local variable, remember that the value of our function's argument is stored 8 bytes above the base pointer, which is not in the function stack frame. Since we have declared a local variable and initialized the value of the argument, the value of the argument needs to be moved into our function stack frame. There is a catch here. Values on the stack cannot be moved directly to another location on the stack.

This is where our general-purpose registers come in. The value of the argument to our function must first be copied into one of our genera-purpose registers, then the value is moved into the memory address 4 bytes below our first variable, and 8 bytes below the base pointer. Now both of our local variables have been initialized and can be accessed for later use.

## Instructions

There are two syntaxes that assembly is normally written in: AT&T and Intel. While the instructions themselves are the same regardless of the syntax, the way the instructions are presented differ, and here I will be covering Intel syntax.

First let's go over the format of an assembly instruction. Every instruction has two parts: the operation and its arguments. Operations can take either one or two arguments. If an operation takes two arguments, they are separated by a coma.

```
operation arg
operaton, arg1, arg2
```

<h3>mov</h3>

The mov instruction takes two arguments, and copies the value referred by its second element into the location referred to by its first element.

```
mov arg1, arg2
```

However, there is one condition. Take the example where we would like to move a local variable on the stack into the rax register. Say that our variable is being stored at rbp-0x8, if the command were to read `mov rax, rbp-0x8`, this would not copy the value of our variable into the register. This is because rbp-0x8 is the address on the stack where our variable is located.


```
//rbp-0x8 = 10

mov rax, rbp-0x8

//rax = *rbp-0x8
```

So instead, this instruction would copy the address of our variable into the register. In order to copy the actual value, or what rbp-0x8 is pointing to, we use square brackets ('[]'). When square brackets are user, the value being pointed to is referenced.

```
//rbp-0x8 = 10

mov rax, [rbp-0x8]

//rax = 10
```

<h3>add</h3>

The add instruction takes two arguments. It adds the values of the two arguments and stores the result in the first argument. For example: if the rax register contained the value 10 and we had the instruction `add rax, 0x5`, the rax register would be updated with the value 15.

<h3>sub</h3>

The sub instruction works exactly the same way as the add instruction, except that instead of the arguments being added, the value of the second argument is subtracted from the first.

<h3>push</h3>

The push instruction places its operand onto the top of the stack, more specifically, it first decrements the stack pointer then places its operand into the location that it points to.

<h3>pop</h3>

The pop instruction takes a register as an argument. It will move the top element of the stack into the register specified by its argument, then increment the stack pointer, thus popping the top element off the stack.

<h3>lea (load effective address)</h3>

The lea instruction stands for load effective address. It places the address specified by its second operand into the register specified by its first operand. This instruction is usually used for obtaining a pointer into a memory region.

<h3>Control Flow of an Executable</h3>

This is where all of the if statements and loops in your code come together to determine the order in which instructions are executed. 

Every instruction has a memory address. This is the area in memory where the instruction is stored. The `rip` register, also known as the instruction pointer, always contains the address of the instruction that is currently being executed. The computer will execute whatever the instruction pointer (rip) is pointing to, and then the instruction pointer will be moved to the next instruction.

<h3>cmp</h3>

the compare (cmp) is actually equivalent to the sub instruction, except that instead of storing the result into the first  argument, it will set a flag in the processor that contains the value `0`, `> 0` or `< 0`. For example, if we had the instruction `cmp 1,3`, this would subtract 3 from 1, and since -1 is less than 0, the flag would be set accordingly.

<h3>jump</h3>

Compare `cmp` instructions are always followed by a `jump` instruction. Every jump instruction takes an instruction address as its argument. It will check the current state of the flag, and depending on the state, set the instruction pointer to its argument. There are many types of jump instructions, some include: `je` (jump if equal to), `jne` (jump if not equalt to). `jg` (jump if greater than) and `jl` (jump if less than).

So, if the instruction from our last example `cmp 1,3` was followed by the instruction `jl` (jump if less than), the jump would be taken. 

If instead we had `jg` (jump if greater than), the instruction would not be taken, and the instruction pointer  would simply move on to the next instruction.

<h3>call</h3>

The `call` instruction calls a function, whether it be a user-defined function or a `PLT` function such as `printf` or `scanf`. This instruction takes one argument. It is equivalent to `push rip`, `jump arg`. In other words, it will push the return address of the function being called on the stack and then move `rip` to the first instruction of the function.

<h3>leave/ret</h3>

The `leave` instruction is called at the end of every function. It essentially destroys the current stack frame by setting the stack pointer to the base pointer and popping the base pointer of the top of the stack.

The `ret` (return) instruction always follows the leave instruction. Since the base pointer has already been popped of the stack.

The `ret addr` (return address) of the function  is now on the top of the stack. the `ret` instruction will pop the `ret addr` off the top of the stack, and then set the instruction pointer to that address.

