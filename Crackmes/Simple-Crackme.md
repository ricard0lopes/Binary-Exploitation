<h1>Crackme</h1>

Resource: https://github.com/LiveOverflow/liveoverflow_youtube/blob/master/0x05_simple_crackme_intro_assembler/license_1

This is crackme of a simple C program. It is supposed to be a simple license check, where we can execute it and suply a key as an argument.

```
┌─[isildur@parrot]─[~/Binary-Exploitation/binaries]
└──╼ $ls
license_1
┌─[isildur@parrot]─[~/Binary-Exploitation/binaries]
└──╼ $./license_1 
Usage: <key>
┌─[isildur@parrot]─[~/Binary-Exploitation/binaries]
└──╼ $./license_1 KEY-000-1111
Checking License: KEY-000-1111
WRONG!
┌─[isildur@parrot]─[~/Binary-Exploitation/binaries]
└──╼ $

```

The goal is to crack this program so that we don't have to use a valid license key.

To have a look at the binary assembler code, we can use a program called `gdb` (GNU Debugger).

```
┌─[isildur@parrot]─[~/Binary-Exploitation/binaries]
└──╼ $gdb license_1 
GNU gdb (Debian 8.3.1-1) 8.3.1
Copyright (C) 2019 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from license_1...
(No debugging symbols found in license_1)
(gdb) 

```

Every C program has a main function. By typping `disassemble main` we can display all the assembler instructions from the main function.

```
(gdb) disassemble main
Dump of assembler code for function main:
   0x00000000004005bd <+0>:     push   %rbp
   0x00000000004005be <+1>:     mov    %rsp,%rbp
   0x00000000004005c1 <+4>:     sub    $0x10,%rsp
   0x00000000004005c5 <+8>:     mov    %edi,-0x4(%rbp)
   0x00000000004005c8 <+11>:    mov    %rsi,-0x10(%rbp)
   0x00000000004005cc <+15>:    cmpl   $0x2,-0x4(%rbp)
   0x00000000004005d0 <+19>:    jne    0x400623 <main+102>
   0x00000000004005d2 <+21>:    mov    -0x10(%rbp),%rax
   0x00000000004005d6 <+25>:    add    $0x8,%rax
   0x00000000004005da <+29>:    mov    (%rax),%rax
   0x00000000004005dd <+32>:    mov    %rax,%rsi
   0x00000000004005e0 <+35>:    mov    $0x4006c4,%edi
   0x00000000004005e5 <+40>:    mov    $0x0,%eax
   0x00000000004005ea <+45>:    callq  0x400490 <printf@plt>
   0x00000000004005ef <+50>:    mov    -0x10(%rbp),%rax
   0x00000000004005f3 <+54>:    add    $0x8,%rax
   0x00000000004005f7 <+58>:    mov    (%rax),%rax
   0x00000000004005fa <+61>:    mov    $0x4006da,%esi
   0x00000000004005ff <+66>:    mov    %rax,%rdi
   0x0000000000400602 <+69>:    callq  0x4004b0 <strcmp@plt>
   0x0000000000400607 <+74>:    test   %eax,%eax
   0x0000000000400609 <+76>:    jne    0x400617 <main+90>
   0x000000000040060b <+78>:    mov    $0x4006ea,%edi
   0x0000000000400610 <+83>:    callq  0x400480 <puts@plt>
   0x0000000000400615 <+88>:    jmp    0x40062d <main+112>
   0x0000000000400617 <+90>:    mov    $0x4006fa,%edi
   0x000000000040061c <+95>:    callq  0x400480 <puts@plt>
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400621 <+100>:   jmp    0x40062d <main+112>
   0x0000000000400623 <+102>:   mov    $0x400701,%edi
   0x0000000000400628 <+107>:   callq  0x400480 <puts@plt>
   0x000000000040062d <+112>:   mov    $0x0,%eax
   0x0000000000400632 <+117>:   leaveq 
   0x0000000000400633 <+118>:   retq   
End of assembler dump.
(gdb) 

```

This displays the main function instructions in AT&T syntax which can be hard to read. To change the syntax to Intel we can type `set disassembly-flavor intel`.

```
(gdb) set disassembly-flavor intel
(gdb) disassemble main
Dump of assembler code for function main:
   0x00000000004005bd <+0>:     push   rbp
   0x00000000004005be <+1>:     mov    rbp,rsp
   0x00000000004005c1 <+4>:     sub    rsp,0x10
   0x00000000004005c5 <+8>:     mov    DWORD PTR [rbp-0x4],edi
   0x00000000004005c8 <+11>:    mov    QWORD PTR [rbp-0x10],rsi
   0x00000000004005cc <+15>:    cmp    DWORD PTR [rbp-0x4],0x2
   0x00000000004005d0 <+19>:    jne    0x400623 <main+102>
   0x00000000004005d2 <+21>:    mov    rax,QWORD PTR [rbp-0x10]
   0x00000000004005d6 <+25>:    add    rax,0x8
   0x00000000004005da <+29>:    mov    rax,QWORD PTR [rax]
   0x00000000004005dd <+32>:    mov    rsi,rax
   0x00000000004005e0 <+35>:    mov    edi,0x4006c4
   0x00000000004005e5 <+40>:    mov    eax,0x0
   0x00000000004005ea <+45>:    call   0x400490 <printf@plt>
   0x00000000004005ef <+50>:    mov    rax,QWORD PTR [rbp-0x10]
   0x00000000004005f3 <+54>:    add    rax,0x8
   0x00000000004005f7 <+58>:    mov    rax,QWORD PTR [rax]
   0x00000000004005fa <+61>:    mov    esi,0x4006da
   0x00000000004005ff <+66>:    mov    rdi,rax
   0x0000000000400602 <+69>:    call   0x4004b0 <strcmp@plt>
   0x0000000000400607 <+74>:    test   eax,eax
   0x0000000000400609 <+76>:    jne    0x400617 <main+90>
   0x000000000040060b <+78>:    mov    edi,0x4006ea
   0x0000000000400610 <+83>:    call   0x400480 <puts@plt>
   0x0000000000400615 <+88>:    jmp    0x40062d <main+112>
   0x0000000000400617 <+90>:    mov    edi,0x4006fa
   0x000000000040061c <+95>:    call   0x400480 <puts@plt>
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400621 <+100>:   jmp    0x40062d <main+112>
   0x0000000000400623 <+102>:   mov    edi,0x400701
   0x0000000000400628 <+107>:   call   0x400480 <puts@plt>
   0x000000000040062d <+112>:   mov    eax,0x0
   0x0000000000400632 <+117>:   leave  
   0x0000000000400633 <+118>:   ret    
End of assembler dump.
(gdb) 

```

Now it is much more readable.

Though this instructions look complicated, we can ignore most of it. First of all we can get a high-level view of it, since it doesn't make sense to start going through this, instruction by instruction. This main function calls other functions, so we just need to go through them and create a control flow of the executable.

![crack](https://user-images.githubusercontent.com/57036558/77793342-c6f05800-7061-11ea-8137-f7b1f4a75be6.png)

At the start it arrives at a compare (`cmp`) with the number 2, and afterwards a `jump not equal`, so something is checked if it is 2:

```
5cc   cmp == 2
5d0   jne 623
```


If that is true, we proceed to a `printf` which we know that is a function to display text:

```
5ea   printf
```

Then, comes a `strcmp` (string compare) which compares two strings and returns 0 if both strings were the same:

```
602   strcmp    ; compares strings
607   test eax, eax  ; returns 0 if both are the same
```

After the call we see another `jump not equal`: 

```
609   jne 617
```

So if the zero flag is not set, there will be a `puts` call (prints text like `printf`):

```
617
61c   puts
```

If the original compare with the number 2 was not true, then it woul jump the address `0x400623`, which is at offset `main+102`.
So in that case it prints some other text with `puts` and exits:

```
623
628   call puts
```

Now we have one branch missing which also just prints text:

```
610   call puts
```

We can represent this in a control graph (or flow chart, whatever):

![controlflow](https://user-images.githubusercontent.com/57036558/77793370-d2438380-7061-11ea-864c-68196c803905.png)

Now lets actually execute this and step through it. To do this we first set a breakpoint at the start of main with `break *main`. After the breakpoint is set, we just type `run` to start the program:

```
(gdb) break *main
Breakpoint 1 at 0x4005bd
(gdb) run
Starting program: /home/isildur/Binary-Exploitation/binaries/license_1
```

By starting the program, we hit the breakpoint 1 at this address:

```
Breakpoint 1, 0x00000000004005bd in main ()
(gdb) 
```

Now looking at the registers with `info registers`:

```
(gdb) info registers
rax            0x4005bd            4195773
rbx            0x0                 0
rcx            0x7ffff7fa3718      140737353758488
rdx            0x7fffffffe038      140737488347192
rsi            0x7fffffffe028      140737488347176
rdi            0x1                 1
rbp            0x400640            0x400640 <__libc_csu_init>
rsp            0x7fffffffdf48      0x7fffffffdf48
r8             0x7ffff7fa5a50      140737353767504
r9             0x7ffff7fe3780      140737354020736
r10            0x7ffff7feff00      140737354071808
r11            0x7ffff7e10ad0      140737352108752
r12            0x4004d0            4195536
r13            0x7fffffffe020      140737488347168
r14            0x0                 0
r15            0x0                 0
rip            0x4005bd            0x4005bd <main>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
```

Here we can see that `rip`, the instuction pointer, points to the first address in main. Now we use `si` to step one instruction:

```
rax            0x4005bd            4195773
rbx            0x0                 0
rcx            0x7ffff7fa3718      140737353758488
rdx            0x7fffffffe038      140737488347192
rsi            0x7fffffffe028      140737488347176
rdi            0x1                 1
rbp            0x400640            0x400640 <__libc_csu_init>
rsp            0x7fffffffdf40      0x7fffffffdf40
r8             0x7ffff7fa5a50      140737353767504
r9             0x7ffff7fe3780      140737354020736
r10            0x7ffff7feff00      140737354071808
r11            0x7ffff7e10ad0      140737352108752
r12            0x4004d0            4195536
r13            0x7fffffffe020      140737488347168
r14            0x0                 0
r15            0x0                 0
rip            0x4005be            0x4005be <main+1>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0

```

Now `rip` is at a new address. So now will step through it all and follow the address in our control graph, but use `ni` instead of `si` because `si` would step into function calls, and we only want to step through this main function and not follow stuff like `puts`.

```
(gdb) ni
0x00000000004005c1 in main ()
(gdb) 
0x00000000004005c5 in main ()
(gdb) 
0x00000000004005c8 in main ()
(gdb) 
0x00000000004005cc in main ()
(gdb) 
0x00000000004005d0 in main ()
(gdb) 
0x0000000000400623 in main ()
(gdb) 
0x0000000000400628 in main ()
(gdb) 
Usage: <key>
0x000000000040062d in main ()
(gdb) 
0x0000000000400632 in main ()
(gdb) 
0x0000000000400633 in main ()

```

The jump was at `5d0` and then the next instruction was at `623`, so we followed the jump, which means that whatever was compared to 2, was not 2. And then the program printed the usage information after `628`, which was the las `puts` call. So now we know that `628` call prints the "Usage" information, making it pretty clear that we didn't pass a key to this program, which means that the check at `5cc   cmp == 2` was looking at the arguments (if we supplied a license key).

So now we will run the program again, but this time with a random license key:

```
(gdb) run RRRR-KEY-9999
Starting program: /home/isildur/Binary-Exploitation/binaries/license_1 RRRR-KEY-9999

Breakpoint 1, 0x00000000004005bd in main ()
(gdb) ni
0x00000000004005be in main ()
(gdb) 
0x00000000004005c1 in main ()
(gdb) 
0x00000000004005c5 in main ()
(gdb) 
0x00000000004005c8 in main ()
(gdb) 
0x00000000004005cc in main ()
(gdb) 
0x00000000004005d0 in main ()
(gdb) 
0x00000000004005d2 in main ()
(gdb) 
0x00000000004005d6 in main ()
(gdb) 
0x00000000004005da in main ()
(gdb) 
0x00000000004005dd in main ()
(gdb) 
0x00000000004005e0 in main ()
(gdb) 
0x00000000004005e5 in main ()
(gdb) 
0x00000000004005ea in main ()
(gdb) 
Checking License: RRRR-KEY-9999
0x00000000004005ef in main ()
(gdb) 
0x00000000004005f3 in main ()
(gdb) 
0x00000000004005f7 in main ()
(gdb) 
0x00000000004005fa in main ()
(gdb) 
0x00000000004005ff in main ()
(gdb) 
0x0000000000400602 in main ()
(gdb) 
0x0000000000400607 in main ()
(gdb) 
0x0000000000400609 in main ()
(gdb) 
0x0000000000400617 in main ()
(gdb) 
0x000000000040061c in main ()
(gdb) 
WRONG!
0x0000000000400621 in main ()
(gdb) 
```

Now we know some other things. The `printf` at the `5ea` address is the info that a license key will be checked. Then, when we arrive at `609` and we see that we jump to the `607` address, which means that the `strcmp` failed, and when we continue with `ni` we see that the `puts` at the address `61c` prints the the key we provided is "WRONG!".

Now lets set a breakpoint before the last compare and run the program again (we can set the breakpoint, run the program again and type continue to run the program until the next breakpoint):

```
(gdb) break *0x0000000000400607
Breakpoint 2 at 0x400607
(gdb) run GIM-ETH-EKEY
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/isildur/Binary-Exploitation/binaries/license_1 GIM-ETH-EKEY

Breakpoint 1, 0x00000000004005bd in main ()
(gdb) continue
Continuing.
Checking License: GIM-ETH-EKEY

Breakpoint 2, 0x0000000000400607 in main ()
(gdb) 
```

Now it stopped before we execute the `test eax, eax`.

`EAX` just refers to the first 32bit of the 64bit `RAX` register.

|RAX|EAX|
|---|---|
|0000 0000 0000 0000 0000 0000 0000 0000| 0000 0000 0000 0000 0000 0000 0000 0000|

```
(gdb) info registers
rax            0x6                 6
rbx            0x0                 0
rcx            0xfdffffff          4261412863
rdx            0x41                65
rsi            0x4006da            4196058
rdi            0x7fffffffe36e      140737488348014
rbp            0x7fffffffdf20      0x7fffffffdf20
rsp            0x7fffffffdf10      0x7fffffffdf10
r8             0xffffffff          4294967295
r9             0x1f                31
r10            0x40035f            4195167
r11            0x7ffff7f41710      140737353357072
r12            0x4004d0            4195536
r13            0x7fffffffe000      140737488347136
r14            0x0                 0
r15            0x0                 0
rip            0x400607            0x400607 <main+74>
eflags         0x206               [ PF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
```

Its value is `0x6`, so lets set it to `0` using `set $eax=0`, which would indicate that the `strcmp` was correct and returned `0`.

```
(gdb) set $eax=0
(gdb) info registers
rax            0x0                 0
rbx            0x0                 0
rcx            0xfdffffff          4261412863
rdx            0x41                65
rsi            0x4006da            4196058
rdi            0x7fffffffe36e      140737488348014
rbp            0x7fffffffdf20      0x7fffffffdf20
rsp            0x7fffffffdf10      0x7fffffffdf10
r8             0xffffffff          4294967295
r9             0x1f                31
r10            0x40035f            4195167
r11            0x7ffff7f41710      140737353357072
r12            0x4004d0            4195536
r13            0x7fffffffe000      140737488347136
r14            0x0                 0
r15            0x0                 0
rip            0x400607            0x400607 <main+74>
eflags         0x206               [ PF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
```

Now we can see that it is successfully set to `0`. Now we use `ni` again to step and follow our control path

```
(gdb) ni
0x0000000000400609 in main ()
(gdb) 
0x000000000040060b in main ()
(gdb) 
0x0000000000400610 in main ()
(gdb) 
Access Granted!
0x0000000000400615 in main ()
(gdb) 
```

And we get the "Access Granted!" message stored at the address `610`, meaning we circumvented the license check.
