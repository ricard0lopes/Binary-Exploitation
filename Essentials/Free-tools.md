<h1>Binary Exploitation tools</h1>

There are different ways to solve the [simple crackme](https://github.com/ricard0lopes/Binary-Exploitation/blob/master/Crackmes/Simple-Crackme.md) exercise using free tools, instead of doing it manually. This is a list of tools and examples of how to use them with the `license_1` binary.

The `file` command is very useful to check what kind of files you have:

```
$file license_1
license_1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=72922f8327afa289f1680c03499675863479489c, not stripped
```

Using `file` on the binary says that it is a `ELF 64-bit` executable for Linux.

There is also a great tool called `strings`, that will scan a file and print out all printable character sequences with at least a certain length:

```
$strings license_1
/lib64/ld-linux-x86-64.so.2
libc.so.6
puts
printf
strcmp
__libc_start_main
__gmon_start__
GLIBC_2.2.5
UH-P
UH-P
[]A\A]A^A_
Checking License: %s
AAAA-Z10N-42-OK
Access Granted!
WRONG!
Usage: <key>
;*3$"
GCC: (Ubuntu 4.8.4-2ubuntu1~14.04) 4.8.4
GCC: (Ubuntu 4.8.2-19ubuntu1) 4.8.2
.symtab
.strtab
.shstrtab
.interp
.note.ABI-tag
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.dynamic
.got
.got.plt
.data
.bss
.comment
crtstuff.c
__JCR_LIST__
deregister_tm_clones
register_tm_clones
__do_global_dtors_aux
completed.6973
__do_global_dtors_aux_fini_array_entry
frame_dummy
__frame_dummy_init_array_entry
crack.c
__FRAME_END__
__JCR_END__
__init_array_end
_DYNAMIC
__init_array_start
_GLOBAL_OFFSET_TABLE_
__libc_csu_fini
_ITM_deregisterTMCloneTable
data_start
puts@@GLIBC_2.2.5
_edata
_fini
printf@@GLIBC_2.2.5
__libc_start_main@@GLIBC_2.2.5
__data_start
strcmp@@GLIBC_2.2.5
__gmon_start__
__dso_handle
_IO_stdin_used
__libc_csu_init
_end
_start
__bss_start
main
_Jv_RegisterClasses
__TMC_END__
_ITM_registerTMCloneTable
_init
```

And with it we can see that the license key `AAAA-Z10N-42-OK` was there all this time:

```
$./license_1 AAAA-Z10N-42-OK
Checking License: AAAA-Z10N-42-OK
Access Granted!
```

Last time we used `gdb` to read the disassembly and also debug the program. This time lets just use `objdump` for the disassembly:

```
$objdump -d license_1

license_1:     file format elf64-x86-64


Disassembly of section .init:

0000000000400450 <_init>:
  400450:       48 83 ec 08             sub    $0x8,%rsp
  400454:       48 8b 05 9d 0b 20 00    mov    0x200b9d(%rip),%rax        # 600ff8 <__gmon_start__>
  40045b:       48 85 c0                test   %rax,%rax
  40045e:       74 05                   je     400465 <_init+0x15>
  400460:       e8 5b 00 00 00          callq  4004c0 <__gmon_start__@plt>
  400465:       48 83 c4 08             add    $0x8,%rsp
  400469:       c3                      retq   

Disassembly of section .plt:

0000000000400470 <.plt>:
  400470:       ff 35 92 0b 20 00       pushq  0x200b92(%rip)        # 601008 <_GLOBAL_OFFSET_TABLE_+0x8>
  400476:       ff 25 94 0b 20 00       jmpq   *0x200b94(%rip)        # 601010 <_GLOBAL_OFFSET_TABLE_+0x10>
  40047c:       0f 1f 40 00             nopl   0x0(%rax)

0000000000400480 <puts@plt>:
  400480:       ff 25 92 0b 20 00       jmpq   *0x200b92(%rip)        # 601018 <puts@GLIBC_2.2.5>
  400486:       68 00 00 00 00          pushq  $0x0
  40048b:       e9 e0 ff ff ff          jmpq   400470 <.plt>

0000000000400490 <printf@plt>:
  400490:       ff 25 8a 0b 20 00       jmpq   *0x200b8a(%rip)        # 601020 <printf@GLIBC_2.2.5>
  400496:       68 01 00 00 00          pushq  $0x1
  40049b:       e9 d0 ff ff ff          jmpq   400470 <.plt>

00000000004004a0 <__libc_start_main@plt>:
  4004a0:       ff 25 82 0b 20 00       jmpq   *0x200b82(%rip)        # 601028 <__libc_start_main@GLIBC_2.2.5>
  4004a6:       68 02 00 00 00          pushq  $0x2
  4004ab:       e9 c0 ff ff ff          jmpq   400470 <.plt>

00000000004004b0 <strcmp@plt>:
  4004b0:       ff 25 7a 0b 20 00       jmpq   *0x200b7a(%rip)        # 601030 <strcmp@GLIBC_2.2.5>
  4004b6:       68 03 00 00 00          pushq  $0x3
  4004bb:       e9 b0 ff ff ff          jmpq   400470 <.plt>

00000000004004c0 <__gmon_start__@plt>:
  4004c0:       ff 25 72 0b 20 00       jmpq   *0x200b72(%rip)        # 601038 <__gmon_start__>
  4004c6:       68 04 00 00 00          pushq  $0x4
  4004cb:       e9 a0 ff ff ff          jmpq   400470 <.plt>

Disassembly of section .text:

00000000004004d0 <_start>:
  4004d0:       31 ed                   xor    %ebp,%ebp
  4004d2:       49 89 d1                mov    %rdx,%r9
  4004d5:       5e                      pop    %rsi
  4004d6:       48 89 e2                mov    %rsp,%rdx
  4004d9:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
  4004dd:       50                      push   %rax
  4004de:       54                      push   %rsp
  4004df:       49 c7 c0 b0 06 40 00    mov    $0x4006b0,%r8
  4004e6:       48 c7 c1 40 06 40 00    mov    $0x400640,%rcx
  4004ed:       48 c7 c7 bd 05 40 00    mov    $0x4005bd,%rdi
  4004f4:       e8 a7 ff ff ff          callq  4004a0 <__libc_start_main@plt>
  4004f9:       f4                      hlt    
  4004fa:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)

0000000000400500 <deregister_tm_clones>:
  400500:       b8 57 10 60 00          mov    $0x601057,%eax
  400505:       55                      push   %rbp
  400506:       48 2d 50 10 60 00       sub    $0x601050,%rax
  40050c:       48 83 f8 0e             cmp    $0xe,%rax
  400510:       48 89 e5                mov    %rsp,%rbp
  400513:       77 02                   ja     400517 <deregister_tm_clones+0x17>
  400515:       5d                      pop    %rbp
  400516:       c3                      retq   
  400517:       b8 00 00 00 00          mov    $0x0,%eax
  40051c:       48 85 c0                test   %rax,%rax
  40051f:       74 f4                   je     400515 <deregister_tm_clones+0x15>
  400521:       5d                      pop    %rbp
  400522:       bf 50 10 60 00          mov    $0x601050,%edi
  400527:       ff e0                   jmpq   *%rax
  400529:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

0000000000400530 <register_tm_clones>:
  400530:       b8 50 10 60 00          mov    $0x601050,%eax
  400535:       55                      push   %rbp
  400536:       48 2d 50 10 60 00       sub    $0x601050,%rax
  40053c:       48 c1 f8 03             sar    $0x3,%rax
  400540:       48 89 e5                mov    %rsp,%rbp
  400543:       48 89 c2                mov    %rax,%rdx
  400546:       48 c1 ea 3f             shr    $0x3f,%rdx
  40054a:       48 01 d0                add    %rdx,%rax
  40054d:       48 d1 f8                sar    %rax
  400550:       75 02                   jne    400554 <register_tm_clones+0x24>
  400552:       5d                      pop    %rbp
  400553:       c3                      retq   
  400554:       ba 00 00 00 00          mov    $0x0,%edx
  400559:       48 85 d2                test   %rdx,%rdx
  40055c:       74 f4                   je     400552 <register_tm_clones+0x22>
  40055e:       5d                      pop    %rbp
  40055f:       48 89 c6                mov    %rax,%rsi
  400562:       bf 50 10 60 00          mov    $0x601050,%edi
  400567:       ff e2                   jmpq   *%rdx
  400569:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

0000000000400570 <__do_global_dtors_aux>:
  400570:       80 3d d9 0a 20 00 00    cmpb   $0x0,0x200ad9(%rip)        # 601050 <__TMC_END__>
  400577:       75 11                   jne    40058a <__do_global_dtors_aux+0x1a>
  400579:       55                      push   %rbp
  40057a:       48 89 e5                mov    %rsp,%rbp
  40057d:       e8 7e ff ff ff          callq  400500 <deregister_tm_clones>
  400582:       5d                      pop    %rbp
  400583:       c6 05 c6 0a 20 00 01    movb   $0x1,0x200ac6(%rip)        # 601050 <__TMC_END__>
  40058a:       f3 c3                   repz retq 
  40058c:       0f 1f 40 00             nopl   0x0(%rax)

0000000000400590 <frame_dummy>:
  400590:       48 83 3d 88 08 20 00    cmpq   $0x0,0x200888(%rip)        # 600e20 <__JCR_END__>
  400597:       00 
  400598:       74 1e                   je     4005b8 <frame_dummy+0x28>
  40059a:       b8 00 00 00 00          mov    $0x0,%eax
  40059f:       48 85 c0                test   %rax,%rax
  4005a2:       74 14                   je     4005b8 <frame_dummy+0x28>
  4005a4:       55                      push   %rbp
  4005a5:       bf 20 0e 60 00          mov    $0x600e20,%edi
  4005aa:       48 89 e5                mov    %rsp,%rbp
  4005ad:       ff d0                   callq  *%rax
  4005af:       5d                      pop    %rbp
  4005b0:       e9 7b ff ff ff          jmpq   400530 <register_tm_clones>
  4005b5:       0f 1f 00                nopl   (%rax)
  4005b8:       e9 73 ff ff ff          jmpq   400530 <register_tm_clones>

00000000004005bd <main>:
  4005bd:       55                      push   %rbp
  4005be:       48 89 e5                mov    %rsp,%rbp
  4005c1:       48 83 ec 10             sub    $0x10,%rsp
  4005c5:       89 7d fc                mov    %edi,-0x4(%rbp)
  4005c8:       48 89 75 f0             mov    %rsi,-0x10(%rbp)
  4005cc:       83 7d fc 02             cmpl   $0x2,-0x4(%rbp)
  4005d0:       75 51                   jne    400623 <main+0x66>
  4005d2:       48 8b 45 f0             mov    -0x10(%rbp),%rax
  4005d6:       48 83 c0 08             add    $0x8,%rax
  4005da:       48 8b 00                mov    (%rax),%rax
  4005dd:       48 89 c6                mov    %rax,%rsi
  4005e0:       bf c4 06 40 00          mov    $0x4006c4,%edi
  4005e5:       b8 00 00 00 00          mov    $0x0,%eax
  4005ea:       e8 a1 fe ff ff          callq  400490 <printf@plt>
  4005ef:       48 8b 45 f0             mov    -0x10(%rbp),%rax
  4005f3:       48 83 c0 08             add    $0x8,%rax
  4005f7:       48 8b 00                mov    (%rax),%rax
  4005fa:       be da 06 40 00          mov    $0x4006da,%esi
  4005ff:       48 89 c7                mov    %rax,%rdi
  400602:       e8 a9 fe ff ff          callq  4004b0 <strcmp@plt>
  400607:       85 c0                   test   %eax,%eax
  400609:       75 0c                   jne    400617 <main+0x5a>
  40060b:       bf ea 06 40 00          mov    $0x4006ea,%edi
  400610:       e8 6b fe ff ff          callq  400480 <puts@plt>
  400615:       eb 16                   jmp    40062d <main+0x70>
  400617:       bf fa 06 40 00          mov    $0x4006fa,%edi
  40061c:       e8 5f fe ff ff          callq  400480 <puts@plt>
  400621:       eb 0a                   jmp    40062d <main+0x70>
  400623:       bf 01 07 40 00          mov    $0x400701,%edi
  400628:       e8 53 fe ff ff          callq  400480 <puts@plt>
  40062d:       b8 00 00 00 00          mov    $0x0,%eax
  400632:       c9                      leaveq 
  400633:       c3                      retq   
  400634:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  40063b:       00 00 00 
  40063e:       66 90                   xchg   %ax,%ax

0000000000400640 <__libc_csu_init>:
  400640:       41 57                   push   %r15
  400642:       41 89 ff                mov    %edi,%r15d
  400645:       41 56                   push   %r14
  400647:       49 89 f6                mov    %rsi,%r14
  40064a:       41 55                   push   %r13
  40064c:       49 89 d5                mov    %rdx,%r13
  40064f:       41 54                   push   %r12
  400651:       4c 8d 25 b8 07 20 00    lea    0x2007b8(%rip),%r12        # 600e10 <__frame_dummy_init_array_entry>
  400658:       55                      push   %rbp
  400659:       48 8d 2d b8 07 20 00    lea    0x2007b8(%rip),%rbp        # 600e18 <__do_global_dtors_aux_fini_array_entry>
  400660:       53                      push   %rbx
  400661:       4c 29 e5                sub    %r12,%rbp
  400664:       31 db                   xor    %ebx,%ebx
  400666:       48 c1 fd 03             sar    $0x3,%rbp
  40066a:       48 83 ec 08             sub    $0x8,%rsp
  40066e:       e8 dd fd ff ff          callq  400450 <_init>
  400673:       48 85 ed                test   %rbp,%rbp
  400676:       74 1e                   je     400696 <__libc_csu_init+0x56>
  400678:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
  40067f:       00 
  400680:       4c 89 ea                mov    %r13,%rdx
  400683:       4c 89 f6                mov    %r14,%rsi
  400686:       44 89 ff                mov    %r15d,%edi
  400689:       41 ff 14 dc             callq  *(%r12,%rbx,8)
  40068d:       48 83 c3 01             add    $0x1,%rbx
  400691:       48 39 eb                cmp    %rbp,%rbx
  400694:       75 ea                   jne    400680 <__libc_csu_init+0x40>
  400696:       48 83 c4 08             add    $0x8,%rsp
  40069a:       5b                      pop    %rbx
  40069b:       5d                      pop    %rbp
  40069c:       41 5c                   pop    %r12
  40069e:       41 5d                   pop    %r13
  4006a0:       41 5e                   pop    %r14
  4006a2:       41 5f                   pop    %r15
  4006a4:       c3                      retq   
  4006a5:       66 66 2e 0f 1f 84 00    data16 nopw %cs:0x0(%rax,%rax,1)
  4006ac:       00 00 00 00 

00000000004006b0 <__libc_csu_fini>:
  4006b0:       f3 c3                   repz retq 

Disassembly of section .fini:

00000000004006b4 <_fini>:
  4006b4:       48 83 ec 08             sub    $0x8,%rsp
  4006b8:       48 83 c4 08             add    $0x8,%rsp
  4006bc:       c3                      retq   
```

This file has a lot of more code than just the `main` function because the compiler puts a bit more stuff into the actual binary, though, usually only the user created functions like `main` are interesting for us. `objdump` can be used to get a lot of more information about this program.

We can print every header with `objdump -x license_1 | less` and using `less` for easier navigation.  
So first it says the file is a `elf` binary for the `x86-64` architecture:

```
license_1:     file format elf64-x86-64
license_1
architecture: i386:x86-64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000000004004d0
```

The stack is not executable, indicated by the missing `x`, which is interesting once we look at classic buffer overflows:

```
STACK off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4
         filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-
```

And maybe the last interesting info here are the sections. We can see where certain data will later end up in memory. Interesting for us here is the `.text` section:

```
12 .text         000001e2  00000000004004d0  00000000004004d0  000004d0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
```

This section holds our code and it starts at address `4004d0` and if we check the address where the `main` function was, we will notice that it is in there. The other interesting section is the `.rodata` which is the read only data section and where our strings can be found:

```
14 .rodata       0000004e  00000000004006c0  00000000004006c0  000006c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
```

If we open `gdb` and break at the `strcmp`:

```
(gdb) break *0x0000000000400602
Breakpoint 1 at 0x400602
(gdb) r TEST-KEY
Starting program: /home/isildur/Binary-Exploitation/binaries/license_1 TEST-KEY
Checking License: TEST-KEY

Breakpoint 1, 0x0000000000400602 in main ()
(gdb) info registers
rax            0x7fffffffe371      140737488348017
rbx            0x0                 0
rcx            0x0                 0
rdx            0x0                 0
rsi            0x4006da            4196058
rdi            0x7fffffffe371      140737488348017
rbp            0x7fffffffdf20      0x7fffffffdf20
rsp            0x7fffffffdf10      0x7fffffffdf10
r8             0xffffffff          4294967295
r9             0x1b                27
r10            0x7fffffffe371      140737488348017
r11            0x246               582
r12            0x4004d0            4195536
r13            0x7fffffffe000      140737488347136
r14            0x0                 0
r15            0x0                 0
rip            0x400602            0x400602 <main+69>
eflags         0x212               [ AF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
```

We can check the registers, and one of those registers will have an address in from this `.rodata` section:

```
rsi            0x4006da            4196058
```

And we can print this address wiht `x/s` to get our license key again:

```
(gdb) x/s 0x4006da
0x4006da:       "AAAA-Z10N-42-OK"
(gdb) 
```

Another tool is called `strace` and it can trace system calls and signals. Linux offers many different kind of functions called syscalls One of those functions is `write`, and it can be used to write text to the standard output, which we can read on the console. So in `strace`:

```
$strace ./license_1
execve("./license_1", ["./license_1"], 0x7ffc0686ef50 /* 51 vars */) = 0
brk(NULL)                               = 0x209c000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=143791, ...}) = 0
mmap(NULL, 143791, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f65c77a4000
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\320l\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=1820104, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f65c77a2000
mmap(NULL, 1832568, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f65c75e2000
mprotect(0x7f65c7607000, 1642496, PROT_NONE) = 0
mmap(0x7f65c7607000, 1339392, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x25000) = 0x7f65c7607000
mmap(0x7f65c774e000, 299008, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x16c000) = 0x7f65c774e000
mmap(0x7f65c7798000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b5000) = 0x7f65c7798000
mmap(0x7f65c779e000, 13944, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f65c779e000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f65c77a3500) = 0
mprotect(0x7f65c7798000, 12288, PROT_READ) = 0
mprotect(0x600000, 4096, PROT_READ)     = 0
mprotect(0x7f65c77f0000, 4096, PROT_READ) = 0
munmap(0x7f65c77a4000, 143791)          = 0
fstat(1, {st_mode=S_IFCHR|0600, st_rdev=makedev(0x88, 0x1), ...}) = 0
brk(NULL)                               = 0x209c000
brk(0x20bd000)                          = 0x20bd000
write(1, "Usage: <key>\n", 13Usage: <key>
)          = 13
exit_group(0)                           = ?
+++ exited with 0 +++
```

The first line is `execve`, which is the function that tells the linux kernel to now execute this program. And then a lot of stuff happens that we can ignore for now. Somewhere all the way to the bottom, the code written by the user starts (basically the `main` function):

```
write(1, "Usage: <key>\n", 13Usage: <key>
)          = 13
```

And we can see here the write syscalls that were executed with the text that we know.

There is another tool called `ltrace` and similar to `strace`, it traces certain functions, but this time it traces library functions:

```
ltrace ./license_1
__libc_start_main(0x4005bd, 1, 0x7ffedd33ae98, 0x400640 <unfinished ...>
puts("Usage: <key>"Usage: <key>
)                                                              = 13
+++ exited (status 0) +++
```

Functions like `printf` or `strcmp` come from the libc library so `ltrace` can show us their occurrence:

```
 $ltrace ./license_1 KEY-AAAA-BBBB
__libc_start_main(0x4005bd, 2, 0x7ffda85b96e8, 0x400640 <unfinished ...>
printf("Checking License: %s\n", "KEY-AAAA-BBBB"Checking License: KEY-AAAA-BBBB
)                                 = 32
strcmp("KEY-AAAA-BBBB", "AAAA-Z10N-42-OK")                                        = 10
puts("WRONG!"WRONG!
)                                                                    = 7
+++ exited (status 0) +++
```

So first we can see the `printf`, then comes the `strcmp` and it shows us the actual strings it compares. So that also tells us how the license check works in a cool way.

Another tool is `radare2`:

```
$r2 license_1
 -- Step through your seek history with the commands 'u' (undo) and 'U' (redo)
[0x004004d0]> 
```

We can notice this address from objdump earlier, this is the start of the text segment that contains our code. First we run `aaa` to automatically analyse an autoname fucntions:

```
[0x004004d0]> aaa
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze function calls (aac)
[x] Analyze len bytes of instructions for references (aar)
[x] Check for objc references
[x] Check for vtables
[x] Type matching analysis for all functions (aaft)
[x] Propagate noreturn information
[x] Use -AA or aaaa to perform additional experimental analysis.
```

Then use `afl` to print all functions that radare found:

```
[0x004004d0]> afl
0x004004d0    1 41           entry0
0x004004a0    1 6            sym.imp.__libc_start_main
0x00400500    4 41           sym.deregister_tm_clones
0x00400530    4 57           sym.register_tm_clones
0x00400570    3 28           entry.fini0
0x00400590    4 45   -> 42   entry.init0
0x004006b0    1 2            sym.__libc_csu_fini
0x004006b4    1 9            sym._fini
0x00400640    4 101          sym.__libc_csu_init
0x004005bd    6 119          main
0x00400450    3 26           sym._init
0x004004c0    1 6            loc.imp.__gmon_start
0x00400480    1 6            sym.imp.puts
0x00400490    1 6            sym.imp.printf
0x004004b0    1 6            sym.imp.strcmp
```

Each character in radare means something, and with `?` we can get information about what characters we can use. So `afl` shows us we found a main function. Lets change our current location with `s` to seek the location of the cuntion main:

```
[0x004004d0]> s sym.main 
[0x004005bd]> 
```

And we notice the location in the brackets changed. 
With `pdf` we can print the disassembly of the current function:

```
[0x004005bd]> pdf
            ; DATA XREF from entry0 @ 0x4004ed
┌ 119: int main (uint32_t argc, char **argv);
│           ; var char **s1 @ rbp-0x10
│           ; var uint32_t var_4h @ rbp-0x4
│           ; arg uint32_t argc @ rdi
│           ; arg char **argv @ rsi
│           0x004005bd      55             push rbp
│           0x004005be      4889e5         mov rbp, rsp
│           0x004005c1      4883ec10       sub rsp, 0x10
│           0x004005c5      897dfc         mov dword [var_4h], edi     ; argc
│           0x004005c8      488975f0       mov qword [s1], rsi         ; argv
│           0x004005cc      837dfc02       cmp dword [var_4h], 2
│       ┌─< 0x004005d0      7551           jne 0x400623
│       │   0x004005d2      488b45f0       mov rax, qword [s1]
│       │   0x004005d6      4883c008       add rax, 8
│       │   0x004005da      488b00         mov rax, qword [rax]
│       │   0x004005dd      4889c6         mov rsi, rax
│       │   0x004005e0      bfc4064000     mov edi, str.Checking_License:__s ; 0x4006c4 ; "Checking License: %s\n" ; const char *format
│       │   0x004005e5      b800000000     mov eax, 0
│       │   0x004005ea      e8a1feffff     call sym.imp.printf         ; int printf(const char *format)
│       │   0x004005ef      488b45f0       mov rax, qword [s1]
│       │   0x004005f3      4883c008       add rax, 8
│       │   0x004005f7      488b00         mov rax, qword [rax]
│       │   0x004005fa      beda064000     mov esi, str.AAAA_Z10N_42_OK ; 0x4006da ; "AAAA-Z10N-42-OK" ; const char *s2
│       │   0x004005ff      4889c7         mov rdi, rax                ; const char *s1
│       │   0x00400602      e8a9feffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)
│       │   0x00400607      85c0           test eax, eax
│      ┌──< 0x00400609      750c           jne 0x400617
│      ││   0x0040060b      bfea064000     mov edi, str.Access_Granted ; 0x4006ea ; "Access Granted!" ; const char *s
│      ││   0x00400610      e86bfeffff     call sym.imp.puts           ; int puts(const char *s)
│     ┌───< 0x00400615      eb16           jmp 0x40062d
│     │││   ; CODE XREF from main @ 0x400609
│     │└──> 0x00400617      bffa064000     mov edi, str.WRONG          ; 0x4006fa ; "WRONG!" ; const char *s
│     │ │   0x0040061c      e85ffeffff     call sym.imp.puts           ; int puts(const char *s)
│     │┌──< 0x00400621      eb0a           jmp 0x40062d
│     │││   ; CODE XREF from main @ 0x4005d0
│     ││└─> 0x00400623      bf01074000     mov edi, str.Usage:__key    ; 0x400701 ; "Usage: <key>" ; const char *s
│     ││    0x00400628      e853feffff     call sym.imp.puts           ; int puts(const char *s)
│     ││    ; CODE XREFS from main @ 0x400615, 0x400621
│     └└──> 0x0040062d      b800000000     mov eax, 0
│           0x00400632      c9             leave
└           0x00400633      c3             ret

```

It shows us the disassembly with nice arrows showing where branches go to, and creates comments for us with referenced strings.
We can also type `VV` to enter in visual mode:

![visual](https://user-images.githubusercontent.com/57036558/77848824-08464c00-71b7-11ea-8103-23dd5ab1bdcf.png)

This shows us a control-graph view of this function. We can move it around with the arrow keys, and the blue border indicates which box we are currently selecting. With `tab` and `shift+tab` we can select other boxes. When a block is selected we can move it with `shift+hjkl`. With `p` we can can cycle through different representations.

We can also use `radare2` like `gdb` to debug the program.  We start radare with the `-d` flag, stick to the `main` function, analyse all with `aaa` and display the disassembly with `pdf`. Now we place a breakpoint at the start with `db 0x004005bd`:

```
[0x004005bd]> db 0x004005bd
[0x004005bd]> 
```

Now we can go to visual view with `VV`, and we can enter in the command mode with `:`. When we type `:dc` we can run the program. If we look closely we can notice the `rip` in the first box, showing us where the `instruction pointer` currently points at. Wiht `s` we can step instructions, but we should use `S` otherwise we follow functions we don't want to. 

And this is it about the free tools needed for binary exploitation.
